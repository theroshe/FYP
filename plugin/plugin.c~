
#include "plugin.h"
#include "plugin-version.h"
#include "tree.h"
#include "tree-pass.h"
#include "intl.h"
#include "print-tree.h"

#include "tree-pretty-print.h"

#include <stdlib.h>

//Confirm that the plugin is open source.
//GCC exits without this
int plugin_is_GPL_compatible;

//Node to which the atribute will be applied
//Name of the attribute
//TREE_LIST of the arguments (may be null)
//Flags
//Set no_add_attrs on error to prevent attribute application
tree_node* handleBitBand(tree_node ** node, tree name, tree args, int flags, bool * no_add_attrs)
{
  //Tree codes are defined in tree.def
 
  //args is the list of arguments to the attribute

  //  debug_tree(*node);
  //debug_tree(TREE_CHAIN(*node));
  debug_generic_stmt (*node);
 
  //tree_node * current = *node;

  /*  fputs("\n\n", stderr);

  while(current)
    {
      print_node_brief(stderr, "", current, 0);
      current = TREE_CHAIN(current);
    }

  //print_node_brief(stderr, "", TREE_CHAIN(*node), 0);
  fputs("\n\n", stderr);
  */

  int hash;
  struct bucket *b;
  enum machine_mode mode;
  enum tree_code_class tclass;
  int len;
  int i;
  expanded_location xloc;
  enum tree_code code;

  //code = TREE_CODE(*node);
  //tclass = TREE_CODE_CLASS(code);

  //  print_node(
  //	    dump_addr

  /*

  if(TREE_CODE(*node) == RECORD_TYPE)
    {
      /*      printf("RECORD_TYPE\n");
      printf("%d\n", RECORD_OR_UNION_TYPE_P(*node));
      printf("%d\n", TYPE_P(*node));
      printf("%d\n", TREE_TYPE(*node));
      printf("%d\n", TREE_ADDRESSABLE(*node));
      printf("%d\n", TREE_STATIC(*node));
      printf("%d\n", TREE_THIS_VOLATILE(*node));
      printf("%d\n", TREE_READONLY(*node));
      printf("%d\n", TYPE_NAME(*node));
      printf("%d\n", TYPE_ADDR_SPACE(*node));
      
      //type_bino
      //type_attributes

      //look at tree code documentation in tree.def
      if(!TREE_USED(*node))
	{
	  printf("Node unused!\n");
	}
      
      debug_tree(*node);
      
    }
     
  else if(TREE_CODE(*node) == TYPE_DECL)
    {
      printf("TYPE_DECL\n");
      
    }
  else
    {
      printf("Invalid type\n");
    }

*/
}


//Called at end of plugin
void gcc_end(void * gcc_data, void * user_data)
{
  printf("Compilation finished.\n");
}

//Called at attribute registration
void attr_reg(void * gcc_data, void * user_data)
{
  printf("Attribute registration\n");

  //Set up struct with attr information
  //Defined on line 4917 of tree.h
  static struct attribute_spec bit_band = 
    {"bit_band", 0, 1, false, false, false, handleBitBand, false};
  //Name, min argc, max argc, decl_required, type_required, function_type_required,
  //function handler, affects_type_identity
  register_attribute(&bit_band);
}

//Called at plugin initialisation
int plugin_init(struct plugin_name_args *plugin_info, 
		  struct plugin_gcc_version *version)
{
  //Check GCC version
  if(!plugin_default_version_check (version, &gcc_version))
    {
      printf("This plugin is meant for use with gcc %s\n", version->basever);
      return 1;
    }

  //printf("%s\n%s\n%s\n%s\n", plugin_info->base_name, plugin_info->full_name,
  // plugin_info->version, plugin_info->help);


  //Register callback functions for GCC events
  //Events are defined in plugin.def
  register_callback("plugin", PLUGIN_FINISH, gcc_end, NULL); //End of plugin
  register_callback("plugin", PLUGIN_ATTRIBUTES, attr_reg, NULL); //Attribute registration

  printf("Plugin loaded successfully\n");
  return 0;
}


